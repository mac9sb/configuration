#!/bin/sh
# =============================================================================
#  Pre-Push Hook — Submodule Hygiene Check
#
#  Prevents pushing when submodules are in an inconsistent state:
#    1. Dirty submodules (uncommitted changes within a submodule)
#    2. Untracked submodule pointer changes (submodule updated but not staged)
#    3. Detached HEAD in submodules (common after `git -C <sub> pull`)
#
#  This catches the common mistake of using `git -C sites/<name> pull`
#  instead of `git submodule update --remote --merge`, which bypasses
#  submodule tracking and leaves the parent repo out of sync.
#
#  Installed to .git/hooks/pre-push by setup.sh
#  Source: ~/Developer/utilities/githooks/pre-push
# =============================================================================

set -e

RED='\033[1;31m'
YELLOW='\033[1;33m'
RESET='\033[0m'

ERRORS=0

# ── 1. Check for dirty submodules (uncommitted changes) ──────────────────────

DIRTY="$(git submodule foreach --quiet '
    if [ -n "$(git status --porcelain 2>/dev/null)" ]; then
        printf "%s\n" "$sm_path"
    fi
')"

if [ -n "$DIRTY" ]; then
    printf "${RED}[pre-push]${RESET} Dirty submodules with uncommitted changes:\n"
    printf '%s\n' "$DIRTY" | while IFS= read -r _path; do
        printf "  ${YELLOW}→${RESET} %s\n" "$_path"
    done
    printf "\n  Commit or stash changes inside the submodule before pushing.\n\n"
    ERRORS=$((ERRORS + 1))
fi

# ── 2. Check for unstaged submodule pointer changes ──────────────────────────
#  This catches the case where someone did `git -C sites/foo pull` which
#  updates the submodule's HEAD but doesn't stage the pointer change in
#  the parent repo. The parent still points at the old commit.

UNSTAGED="$(git diff --name-only --diff-filter=M 2>/dev/null | while IFS= read -r _file; do
    if git ls-files --stage "$_file" 2>/dev/null | grep -q '^160000'; then
        printf '%s\n' "$_file"
    fi
done)"

if [ -n "$UNSTAGED" ]; then
    printf "${RED}[pre-push]${RESET} Submodule pointer changes not staged:\n"
    printf '%s\n' "$UNSTAGED" | while IFS= read -r _path; do
        printf "  ${YELLOW}→${RESET} %s\n" "$_path"
    done
    printf "\n  The submodule was updated (e.g. via git -C) but the parent repo\n"
    printf "  doesn't track the new commit yet. Run:\n"
    printf "    git add <submodule-path> && git commit\n"
    printf "\n  Or use the correct submodule workflow:\n"
    printf "    git submodule update --remote --merge\n"
    printf "    git add <submodule-path> && git commit\n\n"

    ERRORS=$((ERRORS + 1))
fi

# ── 3. Check for detached HEAD in submodules ─────────────────────────────────
#  A detached HEAD often means the submodule was pulled directly instead
#  of through the submodule commands. It's not always an error (submodules
#  are detached by default after `git submodule update`), but combined with
#  other issues it signals a workflow problem.

DETACHED="$(git submodule foreach --quiet '
    if ! git symbolic-ref -q HEAD >/dev/null 2>&1; then
        # Check if the detached commit differs from what the parent expects
        _parent_commit="$(cd "$toplevel" && git ls-tree HEAD "$sm_path" 2>/dev/null | awk "{print \$3}")"
        _current_commit="$(git rev-parse HEAD 2>/dev/null)"
        if [ "$_parent_commit" != "$_current_commit" ]; then
            printf "%s (parent expects %.7s, submodule at %.7s)\n" "$sm_path" "$_parent_commit" "$_current_commit"
        fi
    fi
')"

if [ -n "$DETACHED" ]; then
    printf "${YELLOW}[pre-push]${RESET} Submodules with mismatched detached HEAD:\n"
    printf '%s\n' "$DETACHED" | while IFS= read -r _line; do
        printf "  ${YELLOW}→${RESET} %s\n" "$_line"
    done
    printf "\n  Stage the submodule pointer update:\n"
    printf "    git add <submodule-path> && git commit\n\n"
    ERRORS=$((ERRORS + 1))
fi

# ── 4. Check for submodules not initialised ──────────────────────────────────

UNINIT="$(git submodule status 2>/dev/null | grep '^-' | awk '{print $2}')"

if [ -n "$UNINIT" ]; then
    printf "${YELLOW}[pre-push]${RESET} Uninitialised submodules:\n"
    printf '%s\n' "$UNINIT" | while IFS= read -r _path; do
        printf "  ${YELLOW}→${RESET} %s\n" "$_path"
    done
    printf "\n  Run: git submodule update --init --recursive\n\n"
    # Warning only — don't block push for uninitialised submodules
fi

# ── Result ───────────────────────────────────────────────────────────────────

if [ "$ERRORS" -gt 0 ]; then
    printf "${RED}[pre-push]${RESET} Push blocked — fix %d submodule issue(s) above.\n" "$ERRORS"
    printf "  To bypass (not recommended): git push --no-verify\n\n"
    exit 1
fi

exit 0
